/**
 * TypeDoc plugin for Mintlify MDX output
 * Hooks into TypeDoc's markdown renderer to customize output for Mintlify
 */

import { MarkdownPageEvent } from 'typedoc-plugin-markdown';
import { ReflectionKind, RendererEvent } from 'typedoc';
import * as fs from 'fs';
import * as path from 'path';
import { convertFunctionParameters, convertInterfaceMethodParameters, convertClassMethodParameters } from './typedoc-mintlify-parameters.js';
import { convertFunctionReturns, convertInterfaceMethodReturns, convertClassMethodReturns } from './typedoc-mintlify-returns.js';
import { convertExamplesToCodeGroup, addMintlifyFrontmatter, addHeadingsToCodeGroups } from './typedoc-mintlify-content.js';

/**
 * Plugin load function called by TypeDoc
 */
// Track interfaces that are linked types and should be suppressed
const linkedTypeNames = new Set();

/**
 * Load function called by TypeDoc
 */
export function load(app) {
  console.log('Loading Mintlify TypeDoc plugin...');
  
  app.renderer.on(MarkdownPageEvent.END, (page) => {
    if (!page.contents) return;
    
    let content = page.contents;
    
    // Determine what kind of page this is.
    const isFunction = page.model?.kind === ReflectionKind.Function;
    const isClass = page.model?.kind === ReflectionKind.Class;
    const isInterface = page.model?.kind === ReflectionKind.Interface;
    
    
    // 1. Remove breadcrumbs navigation
    content = content.replace(/^\[.*?\]\(.*?\)\s*\n+/m, '');
    
    // 2. Convert parameters to ParamField components and returns to ResponseField components
    // Functions: ## Parameters/Returns with ### field names
    // Interface methods: #### Parameters/Returns with ##### field names
    // Class methods: #### Parameters/Returns with ##### field names
    const writeLinkedTypesFile = createWriteLinkedTypesFile(app);
    
    if (isFunction) {
      content = convertFunctionParameters(content, app, page, linkedTypeNames, writeLinkedTypesFile);
      content = convertFunctionReturns(content, app, page, linkedTypeNames, writeLinkedTypesFile);
    } else if (isInterface) {
      content = convertInterfaceMethodParameters(content, app, page);
      content = convertInterfaceMethodReturns(content, app, page, linkedTypeNames, writeLinkedTypesFile);
    } else if (isClass) {
      content = convertClassMethodParameters(content, app, page);
      content = convertClassMethodReturns(content, app, page, linkedTypeNames, writeLinkedTypesFile);
    }
    
    // 3. Convert code examples to CodeGroup
    content = convertExamplesToCodeGroup(content);
    
    // 3a. Add headings to CodeGroups that don't have them
    content = addHeadingsToCodeGroups(content);
    
    // 4. Remove auto-generated type links from signatures (keep manual doc links)
    content = stripAutoGeneratedTypeLinks(content);
    
    // 5. Remove .md and .mdx extensions from links
    content = content.replace(/\[([^\]]+)\]\(([^)]+)\.mdx?\)/g, '[$1]($2)');
    
    // 6. Add on-page navigation panel
    content = addOnThisPagePanel(content, page);
    
    // 7. Add frontmatter
    content = addMintlifyFrontmatter(content, page);
    
    page.contents = content;
  });
  
  // Write linked types file once at the end of all processing
  app.renderer.on(MarkdownPageEvent.END, () => {
    // This will run after all pages are processed
    // We'll write the file in a different event
  });
  
  // Write linked types file after all pages are processed
  app.renderer.on(RendererEvent.END, () => {
    const writeLinkedTypesFile = createWriteLinkedTypesFile(app);
    writeLinkedTypesFile();
  });
}

/**
 * Write linked types file
 */
function createWriteLinkedTypesFile(app) {
  return () => {
    if (!app || !app.options) {
      return;
    }
    const outputDir = app.options.getValue('out') || 'docs';
    const resolvedOutputDir = path.resolve(outputDir);
    const linkedTypesFile = path.join(resolvedOutputDir, '.linked-types.json');
    try {
      // Ensure content directory exists
      if (!fs.existsSync(resolvedOutputDir)) {
        fs.mkdirSync(resolvedOutputDir, { recursive: true });
      }
      fs.writeFileSync(linkedTypesFile, JSON.stringify(Array.from(linkedTypeNames)), 'utf-8');
    } catch (e) {
      // Ignore errors writing the file
      console.warn('Warning: Could not write linked types file:', e.message);
    }
  };
}

/**
 * Insert a Mintlify Panel with links to method headings (###) for type docs
 */
function addOnThisPagePanel(content, page) {
  const links = getPanelLinksForPage(page, content);
  if (!links || links.length === 0) {
    return content;
  }
  if (content.includes('<Icon icon="align-left" /> **On this page**')) {
    return content;
  }

  const panelLines = [
    '<Panel>',
    '',
    '<Icon icon="align-left" /> **On this page**',
    '',
    ...links.map(({ heading, anchor }) => `- [${heading}](#${anchor})`),
    '',
    '</Panel>',
    ''
  ];

  const panelBlock = panelLines.join('\n');
  const firstSectionIndex = content.indexOf('\n## ');
  if (firstSectionIndex === -1) {
    return `${content}\n\n${panelBlock}`;
  }
  const insertionPoint = firstSectionIndex + 1;
  return `${content.slice(0, insertionPoint)}${panelBlock}${content.slice(insertionPoint)}`;
}

function getPanelLinksForPage(page, content) {
  if (!page?.model || !page.url) {
    return null;
  }
  if (isTypeDoc(page)) {
    return extractHeadings(content, /^###\s+(.+?)\s*$/gm);
  }
  if (isFunctionDoc(page)) {
    return extractHeadings(content, /^##\s+(.+?)\s*$/gm);
  }
  return null;
}

function isTypeDoc(page) {
  const allowedKinds = new Set([ReflectionKind.Interface, ReflectionKind.Class]);
  return allowedKinds.has(page.model.kind) &&
    (page.url.startsWith('interfaces/') || page.url.startsWith('classes/'));
}

function isFunctionDoc(page) {
  return page.model.kind === ReflectionKind.Function && page.url.startsWith('functions/');
}

function extractHeadings(content, regex) {
  const headings = [];
  let match;
  while ((match = regex.exec(content)) !== null) {
    const heading = match[1].trim();
    if (!heading) {
      continue;
    }
    headings.push({ heading, anchor: slugifyHeading(heading) });
  }
  return headings;
}

function slugifyHeading(text) {
  return text
    .toLowerCase()
    .replace(/[`~!@#$%^&*()+={}\[\]|\\:;"'<>,.?]/g, '')
    .replace(/\s+/g, '-');
}

function stripAutoGeneratedTypeLinks(content) {
  return content.replace(/^>\s*\*\*.*$/gm, (line) => {
    const withoutCodeLinks = line.replace(/\[`([^`]+)`\]\([^)]+\)/g, '`$1`');
    return withoutCodeLinks.replace(/\[([A-Za-z0-9_.]+)\]\(([^)]+)\)/g, '$1');
  });
}

